<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
    










    







<script defer language="javascript" type="text/javascript" src="/js/bundle.min.145453261a7755f5042a854c4213501d215a8fbe34c08d181c40f803f1315e74.js"></script>





  



    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <link rel="icon" href=/favicon.png>

    
    





  





  
  
  


<!-- Open Graph image and Twitter Card metadata -->

<title itemprop="name">w1redch4d - Parser Workflow</title>
<meta property="og:title" content=w1redch4d&#32;-&#32;Parser&#32;Workflow />
<meta name="twitter:title" content=w1redch4d&#32;-&#32;Parser&#32;Workflow />
<meta itemprop="name" content=w1redch4d&#32;-&#32;Parser&#32;Workflow />
<meta name="application-name" content=w1redch4d&#32;-&#32;Parser&#32;Workflow />
<meta property="og:site_name" content="BloggerCh4d" />


<meta name="description" content="" />
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />


<base href="https://w1redch4d.github.io/post/parser-workflow/" />
<link rel="canonical" href="https://w1redch4d.github.io/post/parser-workflow/" itemprop="url" />
<meta name="url" content="https://w1redch4d.github.io/post/parser-workflow/" />
<meta name="twitter:url" content="https://w1redch4d.github.io/post/parser-workflow/" />
<meta property="og:url" content="https://w1redch4d.github.io/post/parser-workflow/" />


<meta property="og:updated_time" content="2025-04-14T11:39:29&#43;05:30" />


<link rel="sitemap" type="application/xml" title="Sitemap" href='https://w1redch4d.github.io/sitemap.xml' />

<meta name="robots" content="index,follow" />
<meta name="googlebot" content="index,follow" />



  
    <meta name="twitter:site" content="@w1redch4d" />
    <meta name="twitter:creator" content="@w1redch4d" />

<meta property="fb:admins" content="" />


<meta name="apple-mobile-web-app-title" content="BloggerCh4d" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />






<meta name="generator" content="Hugo 0.126.2">


    
    

<link type="text/css" rel="stylesheet" href="/css/bundle.min.6513307315781f29e4509b23a7c150cb384b56fde67b79a46b81eaf6b1b60c1b.css">


    
    <style>
    body {
        --sidebar-bg-color: #1A1B2F;
        --sidebar-img-border-color: #3D3A74;
        --sidebar-p-color: #A0AEC0;
        --sidebar-h1-color: #F0F9FF;
        --sidebar-a-color: #C3F3FF;
        --sidebar-socials-color: #9BE8FF;
        --text-color: #2B2D42;
        --bkg-color: #F9FBFD;
        --post-title-color: #1F2937;
        --list-color: #4C566A;
        --link-color: #00B8D9;
        --date-color: #6D9DC5;
        --table-border-color: #CCEFFF;
        --table-stripe-color: #E6F7FB;
        --code-color: #1B1F23;
        --code-background-color: #D0F0FF;
        --code-block-color: #151515;
        --code-block-background-color: #F0F9FF;
        --moon-sun-color: #8AFFEF;
        --moon-sun-background-color: #2D2A55;
    }
    body.dark-theme {
        --text-color: #CBD5E1;
        --bkg-color: #0D1117;
        --post-title-color: #E0F7FA;
        --list-color: #B0BEC5;
        --link-color: #56CCF2;
        --date-color: #6B8CA4;
        --table-border-color: #3A506B;
        --table-stripe-color: #16202A;
        --code-color: #D6F6FF;
        --code-background-color: #2F3E46;
        --code-block-color: #F0F9FF;
        --code-block-background-color: #1E2A38;
    }
    body {
        background-color: var(--bkg-color);
    }
</style>

</head>

    <body class="dark-theme">
        <div class="wrapper">
            <aside class="sidebar">
    <div class="container sidebar-sticky">
        <div class="light-dark" align="right">
    <button class="btn-light-dark" title="Toggle light/dark mode">
        <svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M6 .278a.768.768 0 0 1 .08.858a7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277c.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316a.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71C0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
        </svg>
        <svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M8 12a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
    </button>
</div>

        <div class="sidebar-about">
    <h1 class="brand">
        
            <a href="https://w1redch4d.github.io/">
                <img src="https://w1redch4d.github.io/images/avatar.jpeg" alt="brand image">
            </a>
        
        
            <a href="https://w1redch4d.github.io/">
                <h1>w1redch4d</h1>
            </a>
        
    </h1>
    <p class="lead">
    Fuzzing my brain till it gets SIGSEGV
    </p>
</div>

        <nav>
    <ul class="sidebar-nav">

        
        
        
        
            

            
                
                
            
                
                
            
            
                
                
                        
                
            
                
                
                        
                
                        
                
                        
                
                        
                
                        
                
                        
                
                        
                
            
        
        
            

            
                
                
            
                
                
                    <li class="heading">
                        <a href="/posts/">Posts</a>
                    </li>
                    
                        <li class="sub-heading">
                            Recent
                        </li>
                        
                            <li class="bullet">
                                <a href="https://w1redch4d.github.io/post/parser-workflow/">Parser Workflow</a>
                            </li>
                        
                            <li class="bullet">
                                <a href="https://w1redch4d.github.io/post/lexical-analysis/">Lexical Analysis</a>
                            </li>
                        
                            <li class="bullet">
                                <a href="https://w1redch4d.github.io/post/compiler-design-principles-in-v8/">Compiler Design Principles in V8</a>
                            </li>
                        
                            <li class="bullet">
                                <a href="https://w1redch4d.github.io/post/compiler-design-1/">Compiler Design 1</a>
                            </li>
                        
                            <li class="bullet">
                                <a href="https://w1redch4d.github.io/post/flareon11/">FlareOn11</a>
                            </li>
                        
                    
                
            
            
                
                
                        
                
            
                
                
                        
                
                        
                
                        
                
                        
                
                        
                
                        
                
                        
                
            
        

    </ul>
</nav>

        
    <a target="_blank" class="social" title="GitHub" href="https://github.com/w1redch4d">
        <svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24">
            <path fill="currentColor" d="M18.88 1.099C18.147.366 17.265 0 16.233 0H3.746C2.714 0 1.832.366 1.099 1.099C.366 1.832 0 2.714 0 3.746v12.487c0 1.032.366 1.914 1.099 2.647c.733.733 1.615 1.099 2.647 1.099H6.66c.19 0 .333-.007.429-.02a.504.504 0 0 0 .286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555 0 0 1-.904-.091a2.026 2.026 0 0 1-.872-.39a1.651 1.651 0 0 1-.572-.8l-.13-.3a3.25 3.25 0 0 0-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956 0 0 1-.17-.156a.723.723 0 0 1-.117-.182c-.026-.061-.004-.111.065-.15c.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1 0 0 1 .631.677c.2.355.44.626.722.813c.282.186.566.28.852.28c.286 0 .533-.022.742-.065a2.59 2.59 0 0 0 .585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907 0 0 1-1.333-.234a5.314 5.314 0 0 1-1.223-.507a3.5 3.5 0 0 1-1.047-.872c-.277-.347-.505-.802-.683-1.365c-.177-.564-.266-1.215-.266-1.952c0-1.049.342-1.942 1.027-2.68c-.32-.788-.29-1.673.091-2.652c.252-.079.625-.02 1.119.175c.494.195.856.362 1.086.5c.23.14.414.257.553.352a9.233 9.233 0 0 1 2.497-.338c.859 0 1.691.113 2.498.338l.494-.312a6.997 6.997 0 0 1 1.197-.572c.46-.174.81-.221 1.054-.143c.39.98.424 1.864.103 2.653c.685.737 1.028 1.63 1.028 2.68c0 .737-.089 1.39-.267 1.957c-.177.568-.407 1.023-.689 1.366a3.65 3.65 0 0 1-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9 0 0 1-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36 0 0 0 .208.189c.096.034.18.056.254.064c.074.01.18.013.318.013h2.914c1.032 0 1.914-.366 2.647-1.099c.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/>
        </svg>
    </a>





    <a target="_blank" class="social" title="X" href="https://x.com/w1redch4d">
        <svg xmlns="http://www.w3.org/2000/svg" width="1.1em" height="1.1em" viewBox="0 0 512 472.799">
            <path fill="currentColor" d="M403.229 0h78.506L310.219 196.04 512 462.799H354.002L230.261 301.007 88.669 462.799h-78.56l183.455-209.683L0 0h161.999l111.856 147.88L403.229 0zm-27.556 415.805h43.505L138.363 44.527h-46.68l283.99 371.278z"/>
        </svg>
    </a>

















        <p class="footnote">
powered by <a target="_blank" href="https://gohugo.io">Hugo</a> | themed with <a target="_blank" href="https://github.com/lukeorth/poison">poison</a>
    <br>
    &copy; 2025 BloggerCh4d. All rights reserved.
</p>

  </div>
</aside>

            <main class="content container">
                <div class="post">
  <div class="info">
  <h1 class="post-title">
    <a href="https://w1redch4d.github.io/post/parser-workflow/">Parser Workflow</a>
  </h1>

  <div class="headline">
    <div>
      
      
      <time datetime=" 2025-04-14T11:39:29&#43;0530" class="post-date">
        April 14, 2025
      </time>
      
      <span> - </span>
      <span class="reading-time">
        
          
        

        <span>20 mins read</span>
      </span>
    </div>

    
    <ul class="tags">
      
      <li class="tag-v8">
        <a href="https://w1redch4d.github.io/tags/v8">v8</a>
      </li>
      
      <li class="tag-compiler design">
        <a href="https://w1redch4d.github.io/tags/compiler-design">compiler design</a>
      </li>
      
      <li class="tag-parsing">
        <a href="https://w1redch4d.github.io/tags/parsing">parsing</a>
      </li>
      
      <li class="tag-AST">
        <a href="https://w1redch4d.github.io/tags/ast">AST</a>
      </li>
      
    </ul>
    
  </div>

  
  
  <p class="seriesname">
    Series: <a href="https://w1redch4d.github.io/series/understanding-v8-internals">Understanding V8 internals</a>
  </p>
  

  
</div>

  <h1 id="compilation-parser-and-ast">Compilation Parser And AST</h1>
<p>Parsing is the next phase after <a href="https://w1redch4d.github.io/post/lexical-analysis/" target="_blank">Lexical Analysis</a> . It takes the stream of tokens generated by the lexer as input and constructs a hierarchical structure (like an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">AST</a>) that represents the grammatical structure of the program according to the language&rsquo;s syntax and <a href="https://262.ecma-international.org/6.0/" target="_blank">rules</a> . The <a href="https://v8-docs.vercel.app/parser_8cc_source.html" target="_blank"><strong>parser</strong></a> checks if the sequence of tokens forms a valid program in the language.</p>
<p>In V8&rsquo;s pipeline, the parser receives the tokens from the lexer and produces the <a href="https://v8-docs.vercel.app/ast_8cc_source.html" target="_blank">Abstract Syntax Tree (AST)</a> . This AST serves as the foundation for subsequent stages like bytecode generation by the Ignition interpreter and optimizations by the JIT compilers (Sparkplug, Maglev, Turbofan).</p>


<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

    const lsTheme = localStorage.getItem("theme")
    const hugoTheme = document.body.classList.contains("dark-theme") ? "dark" : null
    const currTheme = lsTheme ? lsTheme : hugoTheme;
    const mermaidTheme = currTheme == "light" ? "default" : "dark"

    mermaid.initialize({theme: mermaidTheme});
</script>



<div class="mermaid">
graph TD
    A[Tokens] --> B(Parser);
    B --> C(Abstract Syntax Tree);

</div>

<h2 id="parser-in-v8">Parser in V8</h2>
<p>In the V8 JavaScript engine, once the scanner completes its job, the next critical component in the compilation pipeline is the <strong>&ldquo;parser&rdquo;</strong>. The scanner produces a <a href="https://w1redch4d.github.io/post/lexical-analysis/#token-class" target="_blank">sequence of tokens</a>, which serve as the primary input for the parser. As the parser works through the process of compiling JavaScript code, it continuously interacts with the scanner, frequently invoking it to supply the next set of tokens needed for parsing. To understand this interaction more deeply, we can examine a specific part of the parser’s implementation. A good starting point for this exploration is the <a href="https://v8-docs.vercel.app/parser_8cc_source.html#l00714" target="_blank"><code>DoParseProgram</code></a> function, which plays a central role in initiating the parsing of JavaScript programs. By analyzing this function, we can gain valuable insights into how the parser operates and how it coordinates with the scanner during the compilation process.</p>
<p>The <code>result</code> variable <a href="https://v8-docs.vercel.app/parser_8cc_source.html#l00725" target="_blank">defined in the function</a> in this case will later hold the Abstract Syntax Tree (AST). The AST is a structured representation of the JavaScript code that the parser builds as it processes the tokens. Once the <code>DoParseProgram()</code> function finishes its execution, the complete AST is generated and stored in this <code>result</code> variable. In the context of our example, after the AST has been successfully constructed, the program proceeds to invoke the next method in the compilation sequence, which continues the process based on the parsed and structured code. However following <a href="https://w1redch4d.github.io/post/lexical-analysis/#lexer-in-v8" target="_blank">our testcase back in the previous module</a> the <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l05638" target="_blank"><code>ParseStatementList</code></a> method will be called, it is responsible for parsing the program statements. Inside the method when <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l05644" target="_blank"><code>peek</code> is called</a> , it takes out the type of the token, for our testcase the type obtained by the <a href="https://v8-docs.vercel.app/scanner_8h_source.html#l00326" target="_blank"><code>peek</code></a> method is <code>Token::kFunction</code> hence the result of the first while loop in the method is false and it jumps to <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l05692" target="_blank">the second while loop</a> and invokes the method <a href="http://v8-docs.vercel.app/parser-base_8h_source.html#l05702" target="_blank"><code>ParseStatementListItem()</code></a>. After the function is called we hit a large <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l05722" target="_blank">switch case</a> which takes actions based on the token type determined by the <code>peek()</code> method , since our token type is <code>Token::kFunction</code> we hit the <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l05724" target="_blank"><code>return ParseHoistableDeclaration(nullptr, false);</code></a> and the <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l04655" target="_blank"><code>ParseHoistableDeclaration(ZonePtrList&lt;const AstRawString&gt;* names, bool default_export)</code></a> method is called. Inside the method we encouter <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l04658" target="_blank"><code>Consume(Token::kFunction);</code></a>, that <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l00941" target="_blank"><code>Consume(Token::Value token)</code></a> method is the token cache we talked about in the <a href="https://w1redch4d.github.io/post/intro-v8/#js-engine-pipeline-v8" target="_blank">JS Engine Pipeline of V8&rsquo;s parser in the first article Intro to V8</a>. After obtaining the token type , we need to figure out <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l04715" target="_blank">which <code>FunctionKind</code> the function is</a>. The <code>Token::kFunction</code> and <a href="https://v8-docs.vercel.app/function-kind_8h_source.html#l00014" target="_blank"><code>FunctionKind</code></a> serves two different purposes as, <code>Token::kFunction</code> is just a part of the JS Engine pipeline in V8 but <code>FunctionKind</code> is an <a href="https://262.ecma-international.org/6.0/#sec-ecmascript-function-objects" target="_blank">ECMA Specs</a>. Now that the parsing part is complete, here is a basic control flow view of the parser in V8 with our testcase :</p>


<div class="mermaid">
graph TD
  A[Start: DoParseProgram] --> B[AST Generation]
  B --> C[ParseStatementList]

  C --> D{peek == Token::kString?}
  D -- Yes --> E[ParseStatementListItem]
  E --> F{IsNull - stat?}
  F -- Yes --> G[Return]
  F -- No --> H[Add stat to body]
  H --> I{IsStringLiteral - stat?}
  I -- No --> J[Break loop]
  I -- Yes --> K{use_strict?}
  K -- Yes --> L[RaiseLanguageMode - kStrict]
  L --> M{scope->HasSimpleParameters?}
  M -- No --> N[ReportMessageAt and Return]
  M -- Yes --> D
  K -- No --> O[RaiseLanguageMode - kSloppy] --> D

  D -- No --> P{peek != end_token}
  P -- Yes --> Q[ParseStatementListItem]
  Q --> R{IsNull - stat?}
  R -- Yes --> S[Return]
  R -- No --> T{IsEmptyStatement?}
  T -- Yes --> P
  T -- No --> U[Add stat to body] --> P
  P -- No --> V[End of ParseStatementList]

  Q --> W[ParseHoistableDeclaration]
  W --> X[Consume - Token::kFunction]
  X --> Y[Check - Token::Mul?]
  Y -- Yes --> Z[Set flags]
  Y -- No --> AA[flags = kIsNormal]
  Z --> AB[ParseHoistableDeclaration - pos, flags,...]
  AA --> AB
  AB --> AC[Determine FunctionKind]
  AC --> AD{kNormalFunction?}
  AD -- Yes --> AE[Parse Token::kIdentifier]
  AE --> AF[Parse Complete]

</div>

<h2 id="parser-optimization-techniques-in-v8">Parser Optimization Techniques in V8</h2>
<p><strong>Lazy Parsing</strong> is an optimization technique in V8 , where the main idea is that the JavaScript code is not fully analyzed or processed (i.e., parsed) until it&rsquo;s actually needed — meaning, until the moment it is about to be executed.
In many programs, some parts of the code might never run. For example, code inside an <code>if</code> statement might not execute if the condition is <code>false</code>, or a function might never be called. So, parsing everything right away can waste time and memory.
To avoid this, V8 delays the parsing of such code until it&rsquo;s absolutely necessary — this is what we call lazy parsing. Similarly, it also delays turning the code into executable machine code, which is known as lazy compilation.
By using both lazy parsing and lazy compilation, V8 can run JavaScript more efficiently, especially when dealing with large programs where not all code is used.</p>
<p>For example , in our case, the <code>is_greater</code>’s type is kNormalFunction, which is the function to be executed immediately, so we need to parse it immediately., hence After analyzing the function name (<code>is_greater</code>), <a href="https://v8-docs.vercel.app/parser_8cc_source.html#l02642" target="_blank"><code>ParseFunctionLiteral</code></a> will be called, which is responsible for parsing the function body.</p>
<p>Referring back to our testcase :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">is_greater</span><span class="p">(</span><span class="nx">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">1337</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="s2">&#34;GREATER!!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">is_greater</span><span class="p">(</span><span class="mi">13337</span><span class="p">));</span>
</span></span></code></pre></div><p>You’ll notice that the function <code>is_greater</code> is not executed right away when the program run as first. This behavior meets the condition for lazy parsing. In other words, because the function is not immediately needed, V8 chooses to delay parsing it until it actually gets called.</p>
<p>We can understand this better by looking at the JavaScript code. First, <code>console.log()</code> is executed. Inside that <code>console.log()</code> call, the function <code>is_greater</code> is then invoked. Since <code>is_greater</code> is not used until later, V8 doesn’t need to parse it immediately — which is exactly what lazy parsing aims to optimize.</p>
<p>To confirm this behavior, we can use debugging tools and take a closer look at how V8 handles this function. One way is by setting a breakpoint in the <code>ParseFunctionLiteral</code> method, which is responsible for parsing function definitions. Here is the initial breakpoint screenshot from the debug:</p>
<p><img src="../../assets/img/initial_parser_debug.png" alt="img"></p>
<p>Notice in the callstack , the functions which are being executed is the same as we discussed above, also lets watch the <code>is_lazy</code> and <code>is_top_level</code> variables and see how they changes with further debugging.</p>
<p><img src="../../assets/img/variable_changing_parser.png" alt="img"></p>
<p>From this, we observe that two important member variables — <code>is_lazy</code> and <code>is_top_level</code> — are both set to <code>true</code>. This strongly supports our earlier claim: the function is parsed lazily and is recognized as a top-level function that doesn’t need to be parsed right away.</p>
<p>Additionally, we can inspect the <strong>Abstract Syntax Tree (AST)</strong> — a structural representation of the code — by running the following command:</p>
<pre tabindex="0"><code>./out/x64.debug/d8 --print-ast ../test.js                                                                                    ─╯
[generating bytecode for function: ]
--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME &#34;&#34;
. INFERRED NAME &#34;&#34;
. DECLS
. . FUNCTION &#34;is_greater&#34; = function is_greater
. EXPRESSION STATEMENT at 66
. . kAssign at -1
. . . VAR PROXY local[0] (0x557657fd24c8) (mode = TEMPORARY, assigned = true) &#34;.result&#34;
. . . CALL
. . . . PROPERTY at 74
. . . . . VAR PROXY unallocated (0x557657fd2588) (mode = DYNAMIC_GLOBAL, assigned = false) &#34;console&#34;
. . . . . NAME log
. . . . CALL
. . . . . VAR PROXY unallocated (0x557657fd2370) (mode = VAR, assigned = true) &#34;is_greater&#34;
. . . . . LITERAL 13337
. RETURN at -1
. . VAR PROXY local[0] (0x557657fd24c8) (mode = TEMPORARY, assigned = true) &#34;.result&#34;

[generating bytecode for function: is_greater]
--- AST ---
FUNC at 19
. KIND 0
. LITERAL ID 1
. SUSPEND COUNT 0
. NAME &#34;is_greater&#34;
. INFERRED NAME &#34;&#34;
. PARAMS
. . VAR (0x557657fd2400) (mode = VAR, assigned = false) &#34;a&#34;
. DECLS
. . VARIABLE (0x557657fd2400) (mode = VAR, assigned = false) &#34;a&#34;
. IF at 25
. . CONDITION at 30
. . . kGreaterThan at 30
. . . . VAR PROXY parameter[0] (0x557657fd2400) (mode = VAR, assigned = false) &#34;a&#34;
. . . . LITERAL 1337
. . THEN at -1
. . . BLOCK at -1
. . . . RETURN at 41
. . . . . LITERAL &#34;GREATER!!&#34;
</code></pre><h1 id="case-study-of-a-parser-bug">Case Study of a Parser Bug</h1>
<p>Before we delve into what the bug is we need to clear out the concept of <strong><code>scopes</code></strong> in javascript:</p>
<h2 id="scopes-in-javascript--concept">Scopes in Javascript : Concept</h2>
<p>According to the definition on <a href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" target="_blank">MDN</a> : &ldquo;The <strong>scope</strong> is the current context of execution in which values and expressions are <strong>&ldquo;visible&rdquo;</strong> or can be referenced.&rdquo;</p>
<p>Lets break the definition down into a more simpler term with a code example:</p>
<p>So to simplify, <strong>Scope</strong> is just where a variable can be used in your code. Lets take the following code for example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Global scope
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// Local scope (only inside this function)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Inside function - x:&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// Can access x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Inside function - y:&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// Can access y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">myFunction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Outside function - x:&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// Can access x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Outside function - y:&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// Error: y is not defined
</span></span></span></code></pre></div><p>The variable <code>x</code> can be accessed anywhere on the entire code as it is in the global scope whereas its not the same case with the variable <code>y</code> as it is only scoped to the <code>myFunction</code> method in the code block. However this is a single example, in Javascript there are three main kind of scopes:</p>
<p><strong>Global scope</strong>: The default scope for all code running in script mode.</p>
<p><strong>Module scope</strong>: The scope for code running in module mode.</p>
<p><strong>Function scope</strong>: The scope created with a function.</p>
<p>In our example we saw the example of two out of those three scopes, the function and the global scope. In addition, identifiers declared with certain syntaxes, including let, const, class, or (in strict mode) function, can belong to an additional scope:</p>
<p><strong>Block scope</strong>: The scope created with a pair of curly braces (a block).</p>
<p>Lets understand this with an example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">blockscope</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;UwU it worked&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">blockscope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>Outputs:</p>
<pre tabindex="0"><code>VM77:5 Uncaught ReferenceError: scope is not defined
    at blockscope (&lt;anonymous&gt;:5:17)
    at &lt;anonymous&gt;:1:1
</code></pre><p>on executing the above code, we get a <code>ReferenceError</code> even though we are trying to access the variable within the same function this is because it was declared using the <code>let</code> keyword and hence its scoped the the block it was defined under, which is why it is not <strong>&ldquo;visible&rdquo;</strong> to the engine anywhere outside the block, now lets try the same example using the <code>var</code> keyword instead of the <code>let</code> keyword:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">blockscope</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;UwU it worked&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">blockscope</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>Outputs:</p>
<pre tabindex="0"><code>UwU it worked
</code></pre><p>Now the code starts to function as expected as it is <strong>scoped</strong> to the function and not just the block.</p>
<h3 id="scope-chaining">Scope Chaining</h3>
<p>Whenever the js engine is unable to resolve a variable in the current scope it keeps moving into the outer scope step by step trying to find the said variable, here is a flow diagram for a better understanding:</p>


<div class="mermaid">
flowchart TD
    subgraph Current Scope
        A[Attempt to Resolve Identifier]
    end

    A --> B{Is it Here?}
    B -- Yes --> C[Use Variable]
    B -- No --> D[Move to Outer Scope]

    subgraph Parent Scope
        E[Attempt to Resolve Identifier]
    end

    D --> E
    E --> F{Is it Here?}
    F -- Yes --> C
    F -- No --> G[Move to Next Outer Scope]

    subgraph Global Scope
        H[Attempt to Resolve Identifier]
    end

    G --> H
    H --> I{Is it Here?}
    I -- Yes --> C
    I -- No --> J[ReferenceError: variable is not defined]

</div>

<h2 id="scopes-in-javascript--v8-implementation">Scopes in Javascript : V8 Implementation</h2>
<p>Let us now dig into how these scopes are implemented in v8&rsquo;s parser. According to the <a href="https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M/edit?tab=t.0" target="_blank">v8 design documentation</a>, V8 utilizes different types of parsing scopes, each tailored for specific parsing contexts:</p>
<ul>
<li>
<p><a href="https://v8-docs.vercel.app/expression-scope_8h_source.html#l00044" target="_blank"><strong>ExpressionParsingScope</strong></a>: Used for most ambiguous expression parsing. It tracks expression and pattern errors. However it is completely different from the <code>scopes</code> concept in javascript, <code>ExpressionScope</code> is used during parsing to handle the complexities of JavaScript syntax and to defer decisions about the nature of certain code constructs. It helps in tracking potential interpretations, classifying errors, and gathering information about variables. This information gathered by <code>ExpressionScopes</code> then contributes to the creation of the actual <a href="https://v8-docs.vercel.app/scopes_8h_source.html" target="_blank"><code>Scope</code> within the AST</a>, which represents the program&rsquo;s lexical environment and is used during the execution of the JavaScript code by the interpreter and compilers. Here is the differences in a tabular format for better understanding:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><strong>ExpressionScope</strong></th>
<th><strong>Scope</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Phase</strong></td>
<td>Primarily exists and is used during the <strong>parsing</strong> phase of the JavaScript code.</td>
<td>Represents the <strong>lexical environment</strong> and is a structural element within the <strong>Abstract Syntax Tree (AST)</strong>, persisting beyond parsing and used during the execution phase.</td>
</tr>
<tr>
<td><strong>Purpose</strong></td>
<td>Acts as a <strong>helper object</strong> to manage syntactic <strong>ambiguities</strong> (e.g., object literal vs. destructuring pattern). It helps in <strong>tracking potential interpretations</strong>, classifying errors based on these possibilities without immediate commitment. Also used to <strong>track identifiers</strong> that might become assignment targets, declarations, or unresolved references.</td>
<td>Represents the <strong>lexical scope</strong> of variables, determining their accessibility and lifetime during code execution. It&rsquo;s built during parsing and reflects where variables are declared (global, function, block) and how scope resolution works.</td>
</tr>
<tr>
<td><strong>Lifespan</strong></td>
<td><strong>Temporary</strong> data structure that exists <strong>until the parser has enough information to resolve an ambiguity</strong>. Once the parser determines the correct interpretation, the ExpressionScope is validated and might be discarded.</td>
<td><strong>Persistent</strong> structure within the AST that reflects the program&rsquo;s lexical organization and is used throughout the execution pipeline by the interpreter (Ignition) and JIT compilers (Sparkplug, Maglev, Turbofan).</td>
</tr>
<tr>
<td><strong>Error Handling</strong></td>
<td>Facilitates <strong>deferred error classification</strong> by tracking errors relevant to different potential interpretations (expression, pattern, declaration). Errors are validated and potentially thrown when the scope&rsquo;s purpose becomes clear. <strong>AccumulationScopes</strong> prevent errors from one neighboring expression from affecting others.</td>
<td>Errors related to scope (e.g., undeclared variables) are generally identified and recorded based on the structure of the AST and the established scopes, often after the initial parsing phase.</td>
</tr>
<tr>
<td><strong>Variable Tracking</strong></td>
<td>Used to <strong>track potential variable declarations and assignment targets</strong> during ambiguous parsing situations. This tracking is done in a way that allows for discarding the information if the construct resolves to an expression or marking them as assigned or declared if it resolves to a pattern or declaration.</td>
<td>Explicitly defines where variables are <strong>declared</strong> and manages their scope within the lexical environment. Scope resolution during execution relies on the hierarchical structure of these scopes to find variable bindings.</td>
</tr>
<tr>
<td><strong>Relationship</strong></td>
<td><strong>ExpressionScope facilitates the parsing process</strong> and gathers information that <strong>contributes to the creation of the actual Scope information in the AST</strong>. It helps the parser navigate syntactic ambiguities so that the correct scope structure can be built.</td>
<td><strong>Scope is the result</strong> of the parsing process, reflecting the lexical structure of the code regarding variable accessibility. The information gathered through mechanisms like <strong>ExpressionScope</strong> helps in correctly defining these scopes in the AST.</td>
</tr>
<tr>
<td><strong>Analogy</strong></td>
<td>Can be thought of as a <strong>scratchpad</strong> or a temporary context that the parser uses to explore different syntactic possibilities before committing to a final structure.</td>
<td>Represents the <strong>blueprint</strong> of how variables are organized and accessible during the program&rsquo;s runtime.</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="https://v8-docs.vercel.app/expression-scope_8h_source.html#l00745" target="_blank"><strong>ArrowHeadParsingScope</strong></a>: Used more selectively when there is a strong indication that an arrow function is being parsed. It tracks expression, pattern, and declaration errors. Indicators for using this scope include identifiers followed by <code>=&gt;</code>, <code>async</code> followed by an identifier then <code>=&gt;</code>, <code>(...</code>, and <code>async(...</code>.</p>
</li>
<li>
<p><a href="https://v8-docs.vercel.app/scopes_8h_source.html#l00852" target="_blank"><strong>DeclarationParsingScope</strong></a>: Activated when the parser definitively knows it&rsquo;s parsing a declaration. In this scope, errors are thrown immediately if they are relevant, and no error classification is needed afterwards. Examples of declarations include <code>ParameterDeclaration</code>, <code>VariableDeclaration</code>, and <code>LexicalDeclaration</code>.</p>
</li>
<li>
<p><a href="https://v8-docs.vercel.app/expression-scope_8h_source.html#l00669" target="_blank"><strong>AccumulationScope</strong></a>: Used for managing neighboring expressions, such as within array literals, object literals, and comma-separated expression lists (like arrow function parameters). This scope prevents errors from one expression from incorrectly affecting the parsing of its neighbors and merges errors outwards.</p>
</li>
</ul>
<h3 id="handling-ambiguous-syntax">Handling Ambiguous Syntax</h3>
<p>A key role of these scopes is to handle ambiguities in JavaScript syntax. For instance, object/array literals and destructuring patterns share similar syntax. By using different parsing scopes, V8 can defer the classification of these constructs until more information is available.</p>
<p>Consider the example from the source: <code>{x:[a],y}</code>. Without further context, it&rsquo;s unclear whether this is:</p>
<ul>
<li>An object literal with properties <code>x</code> (an array containing <code>a</code>) and <code>y</code> with value <code>y</code>.</li>
<li>A destructuring target where <code>a</code> would be assigned the value of the incoming object&rsquo;s <code>x</code> and <code>y</code> the value of <code>object.y</code>.</li>
</ul>
<p>The use of classifying scopes like <code>ExpressionParsingScope</code> and <code>ArrowHeadParsingScope</code> allows the parser to track potential errors related to both interpretations (expression and pattern) without immediately committing to one. Once the parser has more context (e.g., if this is on the left-hand side of an assignment), the scope is validated based on the specific subclass, and the correct interpretation is determined.</p>
<p>Another example involves the keyword <code>&quot;let&quot;</code>. While <code>&quot;let&quot;</code> is not allowed as a lexical declaration within an object literal destructuring (e.g., <code>const {a:[let]} = ...</code>), it is valid within an expression context (e.g., <code>({a:[let]})</code>). Different scope types correctly handle this distinction. A <code>DeclarationParsingScope</code> would immediately flag <code>&quot;let&quot;</code> as an error in the first case, while an <code>ExpressionParsingScope</code> would allow it.</p>
<h3 id="case-study--what-is-the-bug">Case Study : What is the bug</h3>
<p>The bug we are going to discuss in this case study is <strong>CVE-2024-5274</strong> which was an in the wild exploit for a flaw on the v8 parser, which was fixed in this <a href="https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_23.html" target="_blank">update</a>. Lets take a look on what the patch for the bug is :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"><span class="gh">diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
</span></span></span><span class="line"><span class="cl"><span class="gh">index 660fdd2..de4df35 100644
</span></span></span><span class="line"><span class="cl"><span class="gh"></span><span class="gd">--- a/src/ast/scopes.cc
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+++ b/src/ast/scopes.cc
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">@@ -2447,7 +2447,7 @@
</span></span></span><span class="line"><span class="cl"><span class="gu"></span>     var-&gt;set_is_used();
</span></span><span class="line"><span class="cl">     if (inner_scope_calls_eval_ &amp;&amp; !var-&gt;is_this()) var-&gt;SetMaybeAssigned();
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl"><span class="gd">-  DCHECK(!var-&gt;has_forced_context_allocation() || var-&gt;is_used());
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+  CHECK(!var-&gt;has_forced_context_allocation() || var-&gt;is_used());
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>   // Global variables do not need to be allocated.
</span></span><span class="line"><span class="cl">   return !var-&gt;IsGlobalObjectProperty() &amp;&amp; var-&gt;is_used();
</span></span><span class="line"><span class="cl"> }
</span></span><span class="line"><span class="cl"><span class="gh">diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
</span></span></span><span class="line"><span class="cl"><span class="gh">index 40914d3..65c338f 100644
</span></span></span><span class="line"><span class="cl"><span class="gh"></span><span class="gd">--- a/src/parsing/parser-base.h
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+++ b/src/parsing/parser-base.h
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gu">@@ -2661,6 +2661,7 @@
</span></span></span><span class="line"><span class="cl"><span class="gu"></span>   }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   FunctionState initializer_state(&amp;function_state_, &amp;scope_, initializer_scope);
</span></span><span class="line"><span class="cl"><span class="gi">+  FunctionParsingScope body_parsing_scope(impl());
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>   AcceptINScope accept_in(this, true);
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   // Each static block has its own var and lexical scope, so make a new var
</span></span></code></pre></div><blockquote>
<p>Note: How we get the patch is by going to <a href="https://chromium-review.googlesource.com/q/bug:341663589" target="_blank">https://chromium-review.googlesource.com/q/bug:341663589</a> the the number after the <code>bug:</code> can be found on the chromium update link, this is generally the rule of thumb for getting the patch on restricted issues for understanding the rootcause of the bug.</p>
</blockquote>
<p>The core of the fix is the introduction of a <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l02873" target="_blank"><code>FunctionParsingScope</code></a> when parsing the static initialization block of a class. Here&rsquo;s a more detailed look at what this implies:</p>
<ul>
<li>
<p><strong><a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l01705" target="_blank"><code>FunctionParsingScope</code></a></strong> : This new variable, when created, stores the current <code>expression_scope_</code> of the parser and restores it upon destruction. This behavior suggests that <code>FunctionParsingScope</code> is designed to create a temporary, isolated scope during the parsing of function-like structures.</p>
</li>
<li>
<p>Blocking the Parent <strong><a href="https://v8-docs.vercel.app/expression-scope_8h_source.html#l00044" target="_blank"><code>ExpressionScope</code></a></strong>: The crucial point is that <code>FunctionParsingScope</code> blocks the <code>ExpressionScope</code> chain from indexing its parent. This means that during the parsing of the static initialization block, the current <code>ExpressionScope</code> will not be able to directly access or be influenced by its enclosing <code>ExpressionScope</code>.</p>
</li>
</ul>
<p>Without this isolation, the parsing process within the static initialization block could have unintended consequences on the parent <code>ExpressionScope</code>. The function <a href="https://v8-docs.vercel.app/expression-scope_8h_source.html#l00162" target="_blank"><code>RecordThisUse</code></a>, is called by <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l01268" target="_blank"><code>UseThis</code></a> function to handle the <code>this</code> keyword. In JavaScript, <code>this</code> has specific scoping rules within functions, such as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">showThis</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">innerThis</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="nx">innerThis</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">showThis</span> <span class="o">=</span> <span class="nx">showThis</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">showThis</span><span class="p">();</span>
</span></span></code></pre></div><p>The output will be:</p>
<pre tabindex="0"><code>false
</code></pre><p>since the <code>this</code> variable cannot be passed between function calls. However, the introduction of ES6 arrow functions brought a change in how the <code>this</code> keyword is handled. Unlike traditional functions, arrow functions can lexically capture the this value from their surrounding scope. This means that within an arrow function, <code>this</code> refers to the <code>this</code> of its outer function or global scope. To correctly support this behavior, the parsing of <code>this</code> within arrow functions requires special handling. As indicated by the <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l01268" target="_blank"><code>UseThis</code></a> function in V8, when the parser encounters the <code>this</code> keyword, it needs to consider the current and enclosing <code>Scopes</code>. The <code>UseThis</code> function <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l01275" target="_blank">checks if the inner (<code>closure_scope</code>) and outer (<code>receiver_scope</code>) Scopes are the same</a>, <strong>&ldquo;which can be a strong indicator that the head of an arrow function is being parsed in which case parser haven&rsquo;t realized yet that <code>closure_scope</code> != <code>receiver_scope</code>&rdquo;</strong>, as shown in the following code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">arg</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">()</span>
</span></span></code></pre></div><p>At the point where the arrow function is being parsed, its lexical scope has not yet been fully established or allocated. Consequently, when the <code>this</code> keyword is encountered within the body of the arrow function, it cannot be immediately bound to a concrete scope. To address this, an intermediate structure—referred to as <code>ExpressionScope</code> is employed to track the usage of this during this preliminary phase.</p>
<p>Specifically, when the parser identifies a reference to <code>this</code> by the <a href="https://v8-docs.vercel.app/parser-base_8h_source.html#l01268" target="_blank"><code>UseThis</code></a> function, it invokes the <a href="https://v8-docs.vercel.app/expression-scope_8h_source.html#l00162" target="_blank"><code>RecordThisUse</code></a> routine, which annotates the current and all enclosing <code>ExpressionScope</code> instances to indicate that the <code>this</code> binding is required. This deferred recording ensures that, once the lexical scope of the arrow function is later finalized and properly instantiated, the appropriate binding for <code>this</code> consistent with the surrounding lexical environment is correctly resolved and allocated. Here is the video of the callstack for a better understanding:</p>
<p><img src="../../assets/videos/callstack.mp4" alt="video"></p>
<p>Now, the core issue arises from the misuse of lexical tracking mechanisms during the parsing and scope resolution of the <code>this</code> keyword within certain special constructs—specifically, class static blocks. These static blocks, although written inside a class body, semantically behave much like function blocks in terms of scoping and execution.</p>
<p>When the <code>this</code> keyword is encountered during the parsing of code inside an arrow function, and prior to the actual allocation of its lexical scope, a mechanism is employed where references to this are deferred via the <code>ExpressionScope</code> chain. This mechanism is designed to bubble up the usage of this until a concrete function or method scope is finally established. The purpose is to ensure that when scope resolution eventually occurs, the correct outer <code>this</code> context (as per lexical scoping rules) is captured.</p>
<p>However, this deferred resolution strategy does not account for all types of code blocks that should terminate the propagation of <code>this</code> usage through the <code>ExpressionScope</code> chain—specifically, class static blocks.</p>
<p>Class static blocks do not have a this binding of their own; and more importantly, any usage of <code>this</code> within them is illegal and should not imply a dependency on an outer lexical <code>this</code>. Yet, since the static block is not currently being treated as a boundary or terminator in the <code>ExpressionScope</code> chain (i.e., not being recognized as a scope that should stop the upward propagation of <code>this</code> usage), any <code>this</code> reference within it is mistakenly marked as an access to an outer lexical <code>this</code>.</p>
<p>As a result, when <code>RecordThisUse</code> propagates the this usage up through the <code>ExpressionScope</code> hierarchy, it ends up incorrectly marking the enclosing function or class constructor as needing a <code>this</code> binding—even though, semantically, the static block should have blocked this propagation.. The PoC is as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">f1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">arg</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">AAA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">static</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">f1</span><span class="p">();</span>
</span></span></code></pre></div><p>Since the outer function <code>f1</code> does not actually use <code>this</code>, but it is marked as <a href="https://v8-docs.vercel.app/variables_8h_source.html#l00078" target="_blank"><code>has_forced_context_allocation</code></a>, triggering the <a href="https://chromium-review.googlesource.com/c/v8/v8/&#43;/5553030/11/src/ast/scopes.cc#b2450" target="_blank"><code>DCHECK</code></a> when allocating this variable.</p>
<p><img src="../../assets/img/crash-v8.png" alt="img"></p>
<p>And here is the control flow of the entire exploit in mermaid view :</p>


<div class="mermaid">
flowchart TD
    A[Start Parsing Arrow Function] --> B{Arrow Function Scope Allocated?}
    B -- No --> C[Use ExpressionScope to Track `this` Usage]
    C --> D[Call RecordThisUse]
    D --> E[Propagate `this` Usage Up Through ExpressionScope Chain]

    E --> F{Encounter Class Static Block?}
    F -- Yes, But Not Marked as Scope Boundary --> G[Continue Propagating Upward]
    G --> H[Incorrectly Mark Outer Function as Using `this`]
    H --> I[Incorrect Scope Resolution / Runtime Error]

    F -- Yes, If Properly Handled --> J[Stop Propagation Here]
    J --> K[Do Not Mark Outer Scope]
    K --> L[Correct Behavior]

    B -- Yes --> M[Bind `this` Normally in Function Scope]
    M --> N[End]

    L --> N
    I --> N

</div>

<p>In the next blog i will delve deeper into bytecode generation and more on the case study of this bug related to it due to the inconsistent bytecode generation and exploiting the bytecode inconsistency. Thanks for reading :D</p>
<h3 id="references-">References :</h3>
<ul>
<li><a href="https://www.darknavy.org/blog/cve_2024_5274_a_minor_flaw_in_v8_parser_leading_to_catastrophes/" target="_blank">Dark Navy Writeup</a></li>
<li><a href="https://t.me/ReseacrhUnity" target="_blank">Members of ResearchUnity Community of telegram</a></li>
</ul>

  
  <hr>
<div class="footer">
    
    
    
    <p>
    This is a post in the <b><a href="https://w1redch4d.github.io/series/understanding-v8-internals">Understanding V8 internals</a></b> series.
        <br>Other posts in this series:
        <ul class="series">
            
            
            
            <li>
                April 14, 2025 -
                
                    Parser Workflow
                
            </li>
            
            <li>
                April 13, 2025 -
                
                    <a href="/post/lexical-analysis/">Lexical Analysis</a>
                
            </li>
            
            <li>
                April 12, 2025 -
                
                    <a href="/post/compiler-design-principles-in-v8/">Compiler Design Principles in V8</a>
                
            </li>
            
            <li>
                April 12, 2025 -
                
                    <a href="/post/compiler-design-1/">Compiler Design 1</a>
                
            </li>
            
            <li>
                April 11, 2025 -
                
                    <a href="/post/intro-v8/">Intro V8</a>
                
            </li>
            
        </ul>
    </p>
    
</div>

  
</div>
            </main>
            
  
    <div class="article-toc ">
    <div class="toc-wrapper">
      <h4 id="contents"></h4>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#parser-in-v8">Parser in V8</a></li>
    <li><a href="#parser-optimization-techniques-in-v8">Parser Optimization Techniques in V8</a></li>
  </ul>

  <ul>
    <li><a href="#scopes-in-javascript--concept">Scopes in Javascript : Concept</a>
      <ul>
        <li><a href="#scope-chaining">Scope Chaining</a></li>
      </ul>
    </li>
    <li><a href="#scopes-in-javascript--v8-implementation">Scopes in Javascript : V8 Implementation</a>
      <ul>
        <li><a href="#handling-ambiguous-syntax">Handling Ambiguous Syntax</a></li>
        <li><a href="#case-study--what-is-the-bug">Case Study : What is the bug</a></li>
        <li><a href="#references-">References :</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>

  

        </div>
    </body>
</html>
